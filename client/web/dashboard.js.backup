document.addEventListener('DOMContentLoaded', () => {
    // Check libraries
    if (typeof Chart === 'undefined' || typeof Plotly === 'undefined') {
        showError("Error: Chart libraries failed to load. Check internet connection.");
        return;
    }
    fetchData();
    // Refresh every 30 seconds
    setInterval(fetchData, 30000);
});

function showError(msg) {
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); background:rgba(255, 51, 102, 0.9); color:white; padding:15px 30px; border-radius:8px; z-index:9999; font-family:"Courier New"; border:1px solid #ff3366; backdrop-filter:blur(5px); box-shadow:0 0 20px rgba(255,51,102,0.4);';
    errorDiv.innerHTML = `<i class="fa-solid fa-triangle-exclamation"></i> ${msg}`;
    document.body.appendChild(errorDiv);
    setTimeout(() => errorDiv.remove(), 10000);
    console.error(msg);
}

async function fetchData() {
    try {
        const response = await fetch('/api/training-data');
        if (!response.ok) throw new Error(`API Error: ${response.status}`);

        const data = await response.json();

        // Update even if minimal data
        if (data) {
            updateDashboard(data.training_log || [], data.antibodies || {});
        } else {
            showError("No data received from backend.");
        }
    } catch (error) {
        showError(`Connection Failed: ${error.message}`);
    }
}

let charts = {};

function updateDashboard(logs, antibodies) {
    try {
        updateStats(logs, antibodies);
        if (logs.length > 0) {
            updateCharts(logs);
            renderConfusionMatrix(logs);
            renderTable(logs);
            renderBlockedTable(logs);
            renderAntibodyTable(logs, antibodies);
        } else {
            renderTable([]);
            renderBlockedTable([]);
            renderAntibodyTable([]);
        }
    } catch (e) {
        showError(`Rendering Error: ${e.message}`);
    }
}

function updateStats(logs, antibodies) {
    const total = logs.length;
    const blocked = logs.filter(l => l.actual_decision === 'BLOCKED').length;
    const accuracy = total > 0 ? (logs.reduce((acc, l) => acc + (l.correct ? 1 : 0), 0) / total * 100) : 0;
    const avgLatency = total > 0 ? (logs.reduce((acc, l) => acc + (l.latency_ms || 0), 0) / total) : 0;

    let antibodyCount = 0;
    if (antibodies && antibodies.vectors) {
        antibodyCount = antibodies.vectors.length;
    }

    document.getElementById('totalRequests').innerText = total;
    document.getElementById('totalBlocked').innerText = blocked;
    document.getElementById('accuracyStat').innerText = accuracy.toFixed(1) + '%';
    document.getElementById('avgLatency').innerText = avgLatency.toFixed(0) + 'ms';
    document.getElementById('totalAntibodies').innerText = antibodyCount;
}

function updateCharts(logs) {
    if (!logs || logs.length === 0) return;

    // 1. Traffic Chart (Requests per 5 minutes)
    // Group by 5 min buckets
    const buckets = {};
    logs.forEach(l => {
        const date = new Date(l.timestamp);
        // Round to nearest 5 min
        const coeff = 1000 * 60 * 5;
        const rounded = new Date(Math.round(date.getTime() / coeff) * coeff);
        const key = rounded.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        buckets[key] = (buckets[key] || 0) + 1;
    });

    const trafficLabels = Object.keys(buckets);
    const trafficData = Object.values(buckets);

    renderChart('trafficChart', 'line', {
        labels: trafficLabels,
        datasets: [{
            label: 'Requests per 5m',
            data: trafficData,
            borderColor: '#00ff88',
            backgroundColor: 'rgba(0, 255, 136, 0.2)',
            fill: true,
            tension: 0.4
        }]
    });

    // 2. Attack Distribution
    const malicious = logs.filter(l => l.expected_label === 'MALICIOUS').length;
    const benign = logs.filter(l => l.expected_label === 'BENIGN').length;

    renderChart('attackDistChart', 'doughnut', {
        labels: ['Benign', 'Malicious'],
        datasets: [{
            data: [benign, malicious],
            backgroundColor: ['#0077be', '#ff3366'],
            borderWidth: 0
        }]
    });

    // 3. Risk vs Latency Scatter
    // 3D Chart & Radar Chart

    // Call separate update functions
    if (window.update3DChart) window.update3DChart(logs);
    if (window.updateRadarChart) window.updateRadarChart(logs);

    // 4. Accuracy Trend (MA)
    const movingAvgWindow = 20;
    const maData = logs.map((l, i, arr) => {
        if (i < movingAvgWindow) return null;
        const subset = arr.slice(i - movingAvgWindow, i);
        return subset.reduce((acc, x) => acc + (x.correct ? 1 : 0), 0) / movingAvgWindow * 100;
    });

    renderChart('accuracyChart', 'line', {
        labels: logs.map((l, i) => i),
        datasets: [{
            label: 'Accuracy (Rolling 20)',
            data: maData,
            borderColor: '#00ff88',
            tension: 0.4,
            pointRadius: 0
        }]
    }, {
        scales: {
            x: { display: false },
            y: { title: { display: true, text: 'Accuracy %' }, min: 0, max: 100 }
        }
    });

    // 5. Confusion Matrix & Risk Dist
    updateRiskDistChart(logs);
    renderConfusionMatrix(logs);

    // 6. Latency History
    updateLatencyChart(logs);
}

function updateLatencyChart(logs) {
    if (!logs || logs.length === 0) return;

    // Sort by timestamp just in case
    const sortedLogs = [...logs].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

    // Extract Data
    const labels = sortedLogs.map(l => {
        const date = new Date(l.timestamp);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    });

    const dataPoints = sortedLogs.map(l => l.latency_ms || 0);

    renderChart('latencyChart', 'line', {
        labels: labels,
        datasets: [{
            label: 'Latency (ms)',
            data: dataPoints,
            borderColor: '#00ccff', // Cyan
            backgroundColor: 'rgba(0, 204, 255, 0.1)',
            borderWidth: 2,
            pointRadius: 2,
            tension: 0.3,
            fill: true
        }]
    }, {
        scales: {
            x: {
                ticks: { maxTicksLimit: 10, color: '#888' },
                grid: { display: false }
            },
            y: {
                title: { display: true, text: 'Latency (ms)', color: '#888' },
                grid: { color: '#333' },
                ticks: { color: '#888' }
            }
        },
        plugins: {
            legend: { display: false }
        }
    });
}

// === Modular Chart Updaters ===

// 3. Risk Cluster 3D (Plotly)
window.update3DChart = function (logsData) {
    const logs = logsData || window.globalLogs || [];
    if (logs.length === 0) return;

    const mode = document.getElementById('axis3dFilter') ? document.getElementById('axis3dFilter').value : 'STANDARD';

    let xData, yData, zData;
    let xLabel, yLabel, zLabel;

    if (mode === 'TIMELINE') {
        xData = logs.map((l, i) => i);
        yData = logs.map(l => l.risk_score);
        zData = logs.map(l => (l.prompt || "").length);
        xLabel = 'Sequence (Time)';
        yLabel = 'Risk Score';
        zLabel = 'Prompt Length';
    } else if (mode === 'LINGUISTIC') {
        const getVocab = (s) => new Set((s || "").split(/\s+/)).size;
        xData = logs.map(l => (l.prompt || "").length);
        yData = logs.map(l => getVocab(l.prompt));
        zData = logs.map(l => l.risk_score);
        xLabel = 'Prompt Length';
        yLabel = 'Unique Words';
        zLabel = 'Risk Score';
    } else {
        xData = logs.map(l => l.risk_score);
        yData = logs.map(l => l.latency_ms || 0);
        zData = logs.map(l => (l.prompt || "").length);
        xLabel = 'Risk Score';
        yLabel = 'Latency (ms)';
        zLabel = 'Prompt Length';
    }

    const scatter3DData = {
        x: xData,
        y: yData,
        z: zData,
        mode: 'markers',
        type: 'scatter3d',
        marker: {
            size: 4,
            color: logs.map(l => l.actual_decision === 'BLOCKED' ? '#ff3366' : '#00ff88'),
            opacity: 0.8
        },
        text: logs.map(l => `Risk: ${l.risk_score}<br>${yLabel}: ${l.latency_ms || 0}<br>Dec: ${l.actual_decision}`)
    };

    const layout3D = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        scene: {
            xaxis: { title: xLabel, color: '#888', gridcolor: '#333' },
            yaxis: { title: yLabel, color: '#888', gridcolor: '#333' },
            zaxis: { title: zLabel, color: '#888', gridcolor: '#333' },
            bgcolor: 'rgba(0,0,0,0)'
        },
        margin: { t: 0, l: 0, r: 0, b: 0 },
        height: 300
    };

    Plotly.newPlot('riskScatter3D', [scatter3DData], layout3D, { displayModeBar: false });
};

// 4. System Health Radar (Chart.js)
// 4. System Health Radar (Attack Resilience & Risk Profile)
window.updateRadarChart = function (logs) {
    // Default categories ensure the chart has shape even without data
    const defaultCategories = [
        'jailbreak', 'injection', 'roleplay', 'social_engineering', 'obfuscation',
        'urgency', 'boiling_frog', 'system_prompt', 'multi_stage', 'false_positive'
    ];

    // Initialize stats for all categories
    const stats = {};
    defaultCategories.forEach(cat => {
        stats[cat] = { total: 0, blocked: 0, riskSum: 0 };
    });

    // Populate with actual log data
    if (logs && logs.length > 0) {
        logs.forEach(l => {
            if (l.attack_type && defaultCategories.includes(l.attack_type)) {
                stats[l.attack_type].total++;
                stats[l.attack_type].riskSum += (l.risk_score || 0);
                if (l.actual_decision === 'BLOCKED') stats[l.attack_type].blocked++;
            }
        });
    }

    const labels = defaultCategories.map(s => s.replace(/_/g, ' ').toUpperCase());

    // Dataset 1: Defense Resilience (Block Rate %)
    const defenseData = defaultCategories.map(cat => {
        const s = stats[cat];
        return s.total > 0 ? Math.round((s.blocked / s.total) * 100) : 0; // 0 if no attacks
    });

    // Dataset 2: Average Risk Intensity (0-100)
    const riskData = defaultCategories.map(cat => {
        const s = stats[cat];
        return s.total > 0 ? Math.round(s.riskSum / s.total) : 0;
    });

    const radarData = {
        labels: labels,
        datasets: [
            {
                label: 'Defense Resilience (%)',
                data: defenseData,
                backgroundColor: 'rgba(0, 255, 136, 0.2)', // Neon Green fill
                borderColor: '#00ff88',
                pointBackgroundColor: '#00ff88',
                pointBorderColor: '#fff',
                borderWidth: 2,
                pointRadius: 3
            },
            {
                label: 'Avg Risk Intensity',
                data: riskData,
                backgroundColor: 'rgba(255, 51, 102, 0.1)', // Red fill (lighter)
                borderColor: '#ff3366',
                pointBackgroundColor: '#ff3366',
                pointBorderColor: '#fff',
                borderWidth: 2,
                pointRadius: 3,
                borderDash: [5, 5] // Dashed line for Risk to distinguish
            }
        ]
    };

    renderChart('healthRadarChart', 'radar', radarData, {
        scales: {
            r: {
                angleLines: { color: 'rgba(255, 255, 255, 0.1)' },
                grid: { color: 'rgba(255, 255, 255, 0.05)', circular: true },
                pointLabels: {
                    color: '#00ccff', // Cyan labels
                    font: { family: 'Courier New', size: 11, weight: 'bold' },
                    backdropColor: 'transparent'
                },
                suggestedMin: 0,
                suggestedMax: 100,
                ticks: {
                    display: false, // Hide concentric numbers for cleaner look
                    backdropColor: 'transparent'
                }
            }
        },
        plugins: {
            legend: {
                display: true,
                labels: { color: '#fff', font: { family: 'Courier New' } }
            },
            tooltip: {
                backgroundColor: 'rgba(0, 0, 0, 0.9)',
                titleColor: '#00ccff',
                bodyColor: '#fff',
                borderColor: '#333',
                borderWidth: 1,
                callbacks: {
                    label: function (context) {
                        return `${context.dataset.label}: ${context.raw}`;
                    }
                }
            }
        },
        maintainAspectRatio: false
    });
};


// 6. Risk Distribution (Histogram)
function updateRiskDistChart(logs) {
    const riskScores = logs.map(l => l.risk_score || 0);
    const riskBuckets = new Array(10).fill(0);
    riskScores.forEach(s => {
        const idx = Math.min(Math.floor(s / 10), 9);
        riskBuckets[idx]++;
    });

    renderChart('riskDistChart', 'bar', {
        labels: ['0-10', '10-20', '20-30', '30-40', '40-50', '50-60', '60-70', '70-80', '80-90', '90-100'],
        datasets: [{
            label: 'Count',
            data: riskBuckets,
            backgroundColor: riskBuckets.map((_, i) => i > 7 ? '#ff3366' : '#00ff88')
        }]
    });
}

// 7. Confusion Matrix
function renderConfusionMatrix(logs) {
    // Basic logic if not present
    const tp = logs.filter(l => l.expected_label === 'MALICIOUS' && l.actual_decision === 'BLOCKED').length;
    const tn = logs.filter(l => l.expected_label === 'BENIGN' && l.actual_decision === 'ALLOWED').length;
    const fp = logs.filter(l => l.expected_label === 'BENIGN' && l.actual_decision === 'BLOCKED').length;
    const fn = logs.filter(l => l.expected_label === 'MALICIOUS' && l.actual_decision === 'ALLOWED').length;

    const data = [{
        z: [[tn, fp], [fn, tp]],
        x: ['Allowed', 'Blocked'],
        y: ['Benign', 'Malicious'],
        type: 'heatmap',
        colorscale: 'Viridis',
        showscale: false
    }];

    const layout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#fff' },
        margin: { t: 20, b: 20, l: 40, r: 20 },
        autosize: true
    };

    Plotly.newPlot('confusionMatrixContainer', data, layout, { displayModeBar: false });
}


function renderTable(logs) {
    const tbody = document.querySelector('#logsTable tbody');
    if (!tbody) return;
    tbody.innerHTML = '';

    if (!logs || logs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding: 20px; color: #666;">No recent activity</td></tr>';
        return;
    }

    // Show last 50
    const recent = logs.slice().reverse().slice(0, 50);

    recent.forEach(log => {
        const row = document.createElement('tr');

        const time = new Date(log.timestamp).toLocaleTimeString();
        // Safe access to prompt
        const promptText = log.prompt || "[No Prompt]";
        const promptShort = promptText.length > 30 ? promptText.substring(0, 30) + '...' : promptText;
        const riskScore = log.risk_score !== undefined ? log.risk_score : 0;
        const decision = log.actual_decision || "UNKNOWN";

        const riskClass = riskScore > 80 ? 'sc-high' : (riskScore > 40 ? 'sc-med' : 'sc-low');
        const decisionBadge = decision === 'BLOCKED' ? 'badge badge-blocked' : 'badge badge-allowed';
        const statusIcon = log.correct ? '<i class="fa-solid fa-check" style="color: #00ff88;"></i>' : '<i class="fa-solid fa-xmark" style="color: #ff3366;"></i>';

        row.innerHTML = `
            <td><span class="mono">${time}</span></td>
            <td title="${promptText.replace(/"/g, '&quot;')}">${promptShort}</td>
            <td><span class="${riskClass}">${riskScore}</span></td>
            <td><span class="${decisionBadge}">${decision}</span></td>
        `;
        tbody.appendChild(row);
    });
}



// Global filter state
window.currentRiskFilter = 'ALL';

function renderBlockedTable(logs) {
    const tbody = document.querySelector('#blockedTable tbody');
    if (!tbody) return;
    tbody.innerHTML = '';

    // Start with ALL logs (not just blocked)
    let threats = logs;

    // Apply Logic:
    // If Filter is ALL: Show BLOCKED only (classic behavior)
    // If Filter is HIGH/MED/LOW: Show Everything in that range (Blocked OR Allowed)

    if (window.currentRiskFilter === 'ALL') {
        threats = threats.filter(l => l.actual_decision === 'BLOCKED');
    } else {
        threats = threats.filter(l => {
            const score = l.risk_score || 0;
            if (window.currentRiskFilter === 'HIGH') return score >= 80;
            if (window.currentRiskFilter === 'MEDIUM') return score >= 40 && score < 80;
            if (window.currentRiskFilter === 'LOW') return score < 40;
            return true;
        });
    }

    // Sort by Risk Score (Descending)
    threats = threats.sort((a, b) => b.risk_score - a.risk_score).slice(0, 50);

    if (threats.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align:center; padding: 20px; color: #666;">No threats matching filter</td></tr>';
        return;
    }

    threats.forEach(log => {
        const row = document.createElement('tr');
        const time = new Date(log.timestamp).toLocaleTimeString();
        const promptText = log.prompt || "[No Prompt]";
        const promptShort = promptText.length > 30 ? promptText.substring(0, 30) + '...' : promptText;

        // Visual indicator for Allowed but Risky
        const decisionClass = log.actual_decision === 'BLOCKED' ? 'sc-high' : 'sc-low'; // Color code risk
        const rowStyle = log.actual_decision === 'ALLOWED' && (log.risk_score || 0) > 40 ? 'color: #ffcc00;' : '';

        row.innerHTML = `
            <td><span class="mono">${time}</span></td>
            <td title="${promptText.replace(/"/g, '&quot;')}">${promptShort}</td>
            <td><span class="${log.risk_score > 50 ? 'sc-high' : 'sc-med'}" style="${rowStyle}">${log.risk_score}</span></td>
            <td class="mono">${log.actual_decision}</td>
        `;
        tbody.appendChild(row);
    });
}

function renderChart(id, type, data, options = {}) {
    const ctx = document.getElementById(id).getContext('2d');

    // Common defaults
    const defaultOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { labels: { color: '#e0e0e0', font: { family: 'Courier New' } } },
            tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#00ff88',
                bodyColor: '#fff',
                borderColor: '#333',
                borderWidth: 1
            }
        },
        scales: {
            x: {
                ticks: { color: '#888', font: { family: 'Courier New' } },
                grid: { color: 'rgba(255, 255, 255, 0.05)' }
            },
            y: {
                ticks: { color: '#888', font: { family: 'Courier New' } },
                grid: { color: 'rgba(255, 255, 255, 0.05)' }
            }
        },
        interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
        }
    };

    // Deep merge options helper or just simplistic override for now to avoid recursion
    // The previous spread ...options.scales?.x etc caused issues if structure mismatch
    // simpler merge:
    const finalOptions = {
        ...defaultOptions,
        ...options,
        scales: {
            x: { ...defaultOptions.scales.x, ...(options.scales?.x || {}) },
            y: { ...defaultOptions.scales.y, ...(options.scales?.y || {}) }
        },
        plugins: {
            ...defaultOptions.plugins,
            ...(options.plugins || {})
        }
    };

    if (charts[id]) {
        charts[id].data = data;
        charts[id].options = finalOptions;
        charts[id].update();
    } else {
        charts[id] = new Chart(ctx, {
            type: type,
            data: data,
            options: finalOptions
        });
    }
}

function renderConfusionMatrix(logs) {
    // TP: Malicious and Blocked
    // TN: Benign and Allowed
    // FP: Benign and Blocked
    // FN: Malicious and Allowed

    let tp = 0, tn = 0, fp = 0, fn = 0;

    logs.forEach(l => {
        const expected = l.expected_label;
        const decision = l.actual_decision;

        if (expected === 'MALICIOUS' && decision === 'BLOCKED') tp++;
        else if (expected === 'BENIGN' && decision === 'ALLOWED') tn++;
        else if (expected === 'BENIGN' && decision === 'BLOCKED') fp++;
        else if (expected === 'MALICIOUS' && decision === 'ALLOWED') fn++;
    });

    const data = [
        {
            z: [[tn, fp], [fn, tp]],
            x: ['Allowed', 'Blocked'],
            y: ['Benign', 'Malicious'],
            type: 'heatmap',
            colorscale: [
                [0, '#0d0d0d'],
                [0.5, '#0077be'],
                [1, '#00ff88']
            ],
            font: { color: '#fff' }
        }
    ];

    const layout = {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#e0e0e0', family: 'Courier New' },
        margin: { t: 30, l: 60, r: 30, b: 30 },
        height: 300,
        xaxis: { title: 'Actual Decision' },
        yaxis: { title: 'Expected Label' }
    };
    Plotly.newPlot('confusionMatrixContainer', data, layout, { displayModeBar: false });
}

// ===== ANTIBODY BREAKDOWN TABLE =====
function renderAntibodyTable(logs, antibodies) {
    const tbody = document.querySelector('#antibodyTable tbody');
    if (!tbody) return;

    console.log('[Antibody Table] Received logs:', logs ? logs.length : 0);
    console.log('[Antibody Table] Received antibodies:', antibodies);

    if (!logs || logs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;">No antibody data</td></tr>';
        return;
    }

    // Get all blocked malicious attacks (these created antibodies)
    const blockedAttacks = logs.filter(log =>
        log.actual_decision === 'BLOCKED' &&
        log.expected_label === 'MALICIOUS'
    );

    console.log('[Antibody Table] Blocked malicious attacks:', blockedAttacks.length);

    if (blockedAttacks.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;">No antibodies created yet</td></tr>';
        return;
    }

    // Get patterns from antibodies metadata
    const patterns = antibodies && antibodies.patterns ? antibodies.patterns : [];

    // Sort by timestamp (most recent first) and limit to match antibody count
    const sorted = blockedAttacks
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, patterns.length || blockedAttacks.length);

    tbody.innerHTML = sorted.map((attack, index) => {
        const truncatedPrompt = attack.prompt.length > 60
            ? attack.prompt.substring(0, 60) + '...'
            : attack.prompt;

        const timestamp = new Date(attack.timestamp).toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });

        // Get pattern for this antibody (patterns are stored in order)
        const pattern = patterns[index] || 'N/A';

        return `
            <tr title="${attack.prompt.replace(/"/g, '&quot;')}">
                <td>${attack.attack_type || 'Unknown'}</td>
                <td style="color: #e74c3c; font-weight: 500;">${pattern}</td>
                <td style="font-family: monospace; font-size: 0.85em;">${truncatedPrompt}</td>
                <td>${timestamp}</td>
            </tr>
        `;
    }).join('');
}
